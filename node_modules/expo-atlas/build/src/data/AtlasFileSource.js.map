{"version":3,"file":"AtlasFileSource.js","sourceRoot":"","sources":["../../../src/data/AtlasFileSource.ts"],"names":[],"mappings":"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","sourcesContent":["import assert from 'assert';\nimport fs from 'fs';\nimport path from 'path';\n\nimport type { PartialAtlasBundle, AtlasBundle, AtlasSource, AtlasModule } from './types';\nimport { name, version } from '../../package.json';\nimport { env } from '../utils/env';\nimport { AtlasValidationError } from '../utils/errors';\nimport { appendJsonLine, forEachJsonLines, parseJsonLine } from '../utils/jsonl';\n\nexport type AtlasMetadata = { name: string; version: string };\n\nexport class AtlasFileSource implements AtlasSource {\n  constructor(public readonly filePath: string) {\n    //\n  }\n\n  listBundles() {\n    return listAtlasEntries(this.filePath);\n  }\n\n  getBundle(id: string) {\n    const numeric = parseInt(id, 10);\n    assert(!Number.isNaN(numeric) && numeric > 1, `Invalid entry ID: ${id}`);\n    return readAtlasEntry(this.filePath, Number(id));\n  }\n\n  hasHmrSupport() {\n    return false;\n  }\n\n  getBundleHmr() {\n    return null;\n  }\n}\n\n/**\n * List all entries without parsing the data.\n * This only reads the bundle name, and adds a line number as ID.\n *\n * @note Ensure the (de)serialization is in sync with both {@link readAtlasEntry} and {@link writeAtlasEntry}.\n */\nexport async function listAtlasEntries(filePath: string) {\n  const bundlePattern = /^\\[\"([^\"]+)\",\"([^\"]+)\",\"([^\"]+)\",\"([^\"]+)\",\"([^\"]+)\"/;\n  const entries: PartialAtlasBundle[] = [];\n\n  await forEachJsonLines(filePath, (contents, line) => {\n    // Skip the metadata line\n    if (line === 1) return;\n\n    const [_, platform, projectRoot, sharedRoot, entryPoint, environment] =\n      contents.match(bundlePattern) ?? [];\n    if (platform && projectRoot && sharedRoot && entryPoint && environment) {\n      entries.push({\n        id: String(line),\n        platform: platform as any,\n        environment: environment as any,\n        projectRoot,\n        sharedRoot,\n        entryPoint,\n      });\n    }\n  });\n\n  return entries;\n}\n\n/**\n * Get the entry by id or line number, and parse the data.\n *\n * @note Ensure the (de)serialization is in sync with both {@link listAtlasEntries} and {@link writeAtlasEntry}.\n */\nexport async function readAtlasEntry(filePath: string, id: number): Promise<AtlasBundle> {\n  const atlasEntry = await parseJsonLine<any[]>(filePath, id);\n  return {\n    id: String(id),\n    // These values are all strings\n    platform: atlasEntry[0],\n    projectRoot: atlasEntry[1],\n    sharedRoot: atlasEntry[2],\n    entryPoint: atlasEntry[3],\n    environment: atlasEntry[4],\n    // These values are more complex\n    runtimeModules: atlasEntry[5],\n    modules: new Map(atlasEntry[6].map((module: AtlasModule) => [module.absolutePath, module])),\n    transformOptions: atlasEntry[7],\n    serializeOptions: atlasEntry[8],\n  };\n}\n\n/** Simple promise to avoid mixing appended data */\nlet writeQueue: Promise<any> = Promise.resolve();\n\n/**\n * Wait until the Atlas file has all data written.\n * Note, this is a workaround whenever `process.exit` is required, avoid if possible.\n * @internal\n */\nexport function waitUntilAtlasFileReady() {\n  return writeQueue;\n}\n\n/**\n * Add a new entry to the Atlas file.\n * This function also ensures the Atlas file is ready to be written to, due to complications with Expo CLI.\n * Eventually, the entry is appended on a new line, so we can load them selectively.\n *\n * @note Ensure the (de)serialization is in sync with both {@link listAtlasEntries} and {@link readAtlasEntry}.\n */\nexport function writeAtlasEntry(filePath: string, entry: AtlasBundle) {\n  const line = [\n    // These values must all be strings, and are available in PartialAtlasBundle type when listing bundles\n    entry.platform,\n    entry.projectRoot,\n    entry.sharedRoot,\n    entry.entryPoint,\n    entry.environment,\n    // These values can be more complex, but are not available in PartialAtlasBundle type when listing bundles\n    entry.runtimeModules,\n    Array.from(entry.modules.values()),\n    entry.transformOptions,\n    entry.serializeOptions,\n  ];\n\n  writeQueue = writeQueue.then(() => appendJsonLine(filePath, line));\n\n  return writeQueue;\n}\n\n/** The default location of the metro file */\nexport function getAtlasPath(projectRoot: string) {\n  return path.join(projectRoot, '.expo/atlas.jsonl');\n}\n\n/** The information to validate if a file is compatible with this library version */\nexport function getAtlasMetdata(): AtlasMetadata {\n  return { name, version };\n}\n\n/** Validate if the file is compatible with this library version */\nexport async function validateAtlasFile(filePath: string, metadata = getAtlasMetdata()) {\n  if (!fs.existsSync(filePath)) {\n    throw new AtlasValidationError('ATLAS_FILE_NOT_FOUND', filePath);\n  }\n\n  if (env.EXPO_ATLAS_NO_VALIDATION) {\n    return;\n  }\n\n  const data = await parseJsonLine(filePath, 1);\n\n  if (data.name !== metadata.name || data.version !== metadata.version) {\n    throw new AtlasValidationError('ATLAS_FILE_INCOMPATIBLE', filePath, data.version);\n  }\n}\n\n/**\n * Create or overwrite the file with basic metadata.\n * This metdata is used by the API to determine version compatibility.\n */\nexport async function createAtlasFile(filePath: string) {\n  await fs.promises.mkdir(path.dirname(filePath), { recursive: true });\n  await fs.promises.rm(filePath, { force: true });\n  await appendJsonLine(filePath, getAtlasMetdata());\n}\n\n/**\n * Create the Atlas file if it doesn't exist, or recreate it if it's incompatible.\n */\nexport async function ensureAtlasFileExist(filePath: string) {\n  try {\n    await validateAtlasFile(filePath);\n  } catch (error: any) {\n    if (error.code === 'ATLAS_FILE_NOT_FOUND' || error.code === 'ATLAS_FILE_INCOMPATIBLE') {\n      await createAtlasFile(filePath);\n      return false;\n    }\n\n    throw error;\n  }\n\n  return true;\n}\n"]}